use std::str::FromStr;
use crate::common::lit::{LitVal, LitType};
use crate::common::prim::{Compare, Prim};
use crate::common::name::Name;
use crate::common::intern::InternStr;
use crate::core::core::{Expr, Type, Decl, Program};

grammar;

pub Nat: usize = <s:r"[0-9]+"> => usize::from_str(s).unwrap();
pub Int: i64 = {
    <n: Nat> => n as i64,
    "-" <n: Nat> => - (n as i64),
}
pub Float: f64 = <s:r"(-)?[0-9]+\.[0-9]+"> => f64::from_str(s).unwrap();
pub Char: char = <s:r"'.'"> => char::from_str(&s[1..2]).unwrap();

pub Bool: bool = {
    "false" => false,
    "true" => true,
};

pub Name: Name = <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> => Name::RawId(InternStr::new(s));

pub LitVal: LitVal = {
    <x: Int> => LitVal::Int(x),
    <x: Float> => LitVal::Float(x),
    <x: Char> => LitVal::Char(x),
    <x: Bool> => LitVal::Bool(x),
};

pub LitType: LitType = {
    "Int" => LitType::TyInt,
    "Float" => LitType::TyFloat,
    "Char" => LitType::TyChar,
    "Bool" => LitType::TyBool,
};

pub Prim: Prim = {
    "@ineg" => Prim::INeg,
    "@iadd" => Prim::IAdd,
    "@isub" => Prim::ISub,
    "@imul" => Prim::IMul,
    "@idiv" => Prim::IDiv,
    "@irem" => Prim::IRem,
    "@icmplt" => Prim::ICmp(Compare::Lt),
    "@icmple" => Prim::ICmp(Compare::Le),
    "@icmpeq" => Prim::ICmp(Compare::Eq),
    "@icmpne" => Prim::ICmp(Compare::Ne),
    "@icmpgt" => Prim::ICmp(Compare::Gt),
    "@icmpge" => Prim::ICmp(Compare::Ge),
    "@fneg" => Prim::FNeg,
    "@fadd" => Prim::FAdd,
    "@fsub" => Prim::FSub,
    "@fmul" => Prim::FMul,
    "@fdiv" => Prim::FDiv,
    "@fcmplt" => Prim::FCmp(Compare::Lt),
    "@fcmple" => Prim::FCmp(Compare::Le),
    "@fcmpeq" => Prim::FCmp(Compare::Eq),
    "@fcmpne" => Prim::FCmp(Compare::Ne),
    "@fcmpgt" => Prim::FCmp(Compare::Gt),
    "@fcmpge" => Prim::FCmp(Compare::Ge),
    "@ccmplt" => Prim::CCmp(Compare::Lt),
    "@ccmple" => Prim::CCmp(Compare::Le),
    "@ccmpeq" => Prim::CCmp(Compare::Eq),
    "@ccmpne" => Prim::CCmp(Compare::Ne),
    "@ccmpgt" => Prim::CCmp(Compare::Gt),
    "@ccmpge" => Prim::CCmp(Compare::Ge),
    "@bnot" => Prim::BNot,
    "@band" => Prim::BAnd,
    "@bor" => Prim::BOr,
    "@bxor" => Prim::BXor,
    "@iscan" => Prim::IScan,
    "@fscan" => Prim::FScan,
    "@cscan" => Prim::CScan,
    "@iprint" => Prim::IPrint,
    "@fprint" => Prim::FPrint,
    "@cprint" => Prim::CPrint,
}

Comma<T>: Vec<T> = {
    <mut xs: (<T> ",")*> <x: T?> => match x {
        None => xs,
        Some(x) => {
            xs.push(x);
            xs
        }
    }
};

pub Type: Type = {
    <lit: LitType> => Type::Lit { lit },
    <var: Name> => Type::Var { var },
    "fn" <gens: ("[" <Comma<Name>> "]")?> "(" <pars: Comma<Type>> ")" "->" <res: Type> =>
        match gens {
            None => Type::Func { pars, res: Box::new(res) },
            Some(gens) => Type::Forall { gens, pars, res: Box::new(res) },
        },
    <seals: ("[" <Comma<Name>> "]")?> "(" <flds: Comma<Type>> ")" =>
        match seals {
            None => match flds.len() {
                0 => Type::Lit { lit: LitType::TyUnit },
                1 => flds.into_iter().next().unwrap(),
                _n => Type::Tup { flds },
            },
            Some(seals) => Type::Exist { seals, flds }
        },
};

pub Expr: Expr = {
    <left: ExprLeft> <rights: ExprRight*> =>
        rights.into_iter().fold(
            left,
            |acc, x| {
                match x {
                    Expr::App { func: _, args } => 
                        Expr::App { func: Box::new(acc), args },
                    Expr::Sel { expr: _, idx } =>
                        Expr::Sel { expr: Box::new(acc), idx },
                    Expr::Inst { expr: _, typs } =>
                        Expr::Inst { expr: Box::new(acc), typs },
                    _ => unsafe { std::hint::unreachable_unchecked() },
                }
            }
        ),
    "let" <bind: Name> "=" <expr: Expr> "in" <cont: Expr> =>
        Expr::Let { bind, expr: Box::new(expr), cont: Box::new(cont)},
    "fn" "(" <pars: Comma<(<Name> ":" <Type>)>> ")" "=>" <body: Expr> =>
        Expr::Func { pars, body: Box::new(body) },
    "letrec" <decls: Decl*> "in" <cont: Expr> "end" =>
        Expr::Letrec { decls, cont: Box::new(cont) },
    "pack" <expr: Expr> "as" "[" <seals: Comma<(<Name> "=" <Type>)>> "]" "(" <flds: Comma<Type>> ")" =>
        Expr::Pack { expr: Box::new(expr), seals, flds },
    "unpack" <bind: Name> "[" <opens: Comma<Name>> "]" "=" <expr: Expr> "in" <cont: Expr> =>
        Expr::Unpack { bind, opens, expr: Box::new(expr), cont: Box::new(cont) },
    "if" <cond: Expr> "then" <trbr: Expr> "else" <flbr: Expr> =>
        Expr::Ifte { cond: Box::new(cond), trbr: Box::new(trbr), flbr: Box::new(flbr) },

}

pub ExprLeft: Expr = {
    <lit: LitVal> => Expr::Lit { lit },
    <var: Name> => Expr::Var { var },
    <prim: Prim> "(" <args: Comma<Expr>> ")" => Expr::Prim { prim, args},
    "(" <flds: Comma<Expr>> ")" => {
        match flds.len() {
            0 => Expr::Lit { lit: LitVal::Unit },
            1 => flds.into_iter().next().unwrap(),
            _n => Expr::Tup { flds },
        }
    },
}

pub ExprRight: Expr = {
    // put dummy value 0 on the left side
    "(" <args: Comma<Expr>> ")" =>
        Expr::App { func: Box::new(Expr::Lit { lit : LitVal::Int(0)}), args },
    "." <idx: Nat> =>
        Expr::Sel { expr: Box::new(Expr::Lit { lit : LitVal::Int(0)}), idx },
    "[" <typs: Comma<Type>> "]" =>
        Expr::Inst { expr: Box::new(Expr::Lit { lit : LitVal::Int(0)}), typs },
}

pub Decl: Decl = {
    "function" <name: Name> <gens: ("[" <Comma<Name>> "]")?> "(" <pars: Comma<(<Name> ":" <Type>)>> ")"
        "->" <res: Type> "begin" <body: Expr> "end" =>
            Decl { name, gens, pars, res, body }
}

pub Program: Program = {
    <decls: Decl*> =>
        Program { decls }
}